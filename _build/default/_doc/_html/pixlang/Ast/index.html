<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (pixlang.Ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">pixlang</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Ast</span></code></h1><p>Module that represent programs in the Pixlang language. A program is composed of a list of arguments, followed by a statement that is the body of the program. Statements contain expressions. Arguments, statements and expressions contain annotations (their position and types).</p><p>This modules contains also a set of printer functions to display programs in a normalised form.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-type_expression"><a href="#type-type_expression" class="anchor"></a><code><span><span class="keyword">type</span> type_expression</span><span> = </span></code><ol><li id="type-type_expression.Type_int" class="def variant constructor anchored"><a href="#type-type_expression.Type_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_int</span></span></code></li><li id="type-type_expression.Type_real" class="def variant constructor anchored"><a href="#type-type_expression.Type_real" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_real</span></span></code></li><li id="type-type_expression.Type_bool" class="def variant constructor anchored"><a href="#type-type_expression.Type_bool" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_bool</span></span></code></li><li id="type-type_expression.Type_coord" class="def variant constructor anchored"><a href="#type-type_expression.Type_coord" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_coord</span></span></code></li><li id="type-type_expression.Type_color" class="def variant constructor anchored"><a href="#type-type_expression.Type_color" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_color</span></span></code></li><li id="type-type_expression.Type_pixel" class="def variant constructor anchored"><a href="#type-type_expression.Type_pixel" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_pixel</span></span></code></li><li id="type-type_expression.Type_list" class="def variant constructor anchored"><a href="#type-type_expression.Type_list" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_list</span> <span class="keyword">of</span> <a href="#type-type_expression">type_expression</a></span></code></li><li id="type-type_expression.Type_generic" class="def variant constructor anchored"><a href="#type-type_expression.Type_generic" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_generic</span></span></code></li></ol></div><div class="spec-doc"><p>Types of the language</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Annotation"><a href="#module-Annotation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Annotation/index.html">Annotation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module representing annotations of elements of the program. It contains the <a href="../Util/Position/index.html#type-t"><code>Util.Position.t</code></a> of the parsed text that represent the element, and its <a href="#type-type_expression"><code>type_expression</code></a>. The type is only useful for expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binary_operator"><a href="#type-binary_operator" class="anchor"></a><code><span><span class="keyword">type</span> binary_operator</span><span> = </span></code><ol><li id="type-binary_operator.Plus" class="def variant constructor anchored"><a href="#type-binary_operator.Plus" class="anchor"></a><code><span>| </span><span><span class="constructor">Plus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Plusition over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>, and concatenation over <a href="#type-type_expression.Type_list"><code>Type_list</code></a>. Also defined if one of the operands is a <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and the other a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> or <a href="#type-type_expression.Type_color"><code>Type_color</code></a>, in which case, the integer is replaced by a pair of a triple (depending of the type) with its value.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Minus" class="def variant constructor anchored"><a href="#type-binary_operator.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Substraction over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>. Also defined if one of the operands is a <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and the other a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> or <a href="#type-type_expression.Type_color"><code>Type_color</code></a>, in which case, the integer is replaced by a pair of a triple (depending of the type) with its value.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Times" class="def variant constructor anchored"><a href="#type-binary_operator.Times" class="anchor"></a><code><span>| </span><span><span class="constructor">Times</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Multiplication over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>. Also defined if one of the operands is a <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and the other a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> or <a href="#type-type_expression.Type_color"><code>Type_color</code></a>, in which case, the integer is replaced by a pair of a triple (depending of the type) with its value.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Div" class="def variant constructor anchored"><a href="#type-binary_operator.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Division over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>. Also defined if one of the operands is a <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and the other a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> or <a href="#type-type_expression.Type_color"><code>Type_color</code></a>, in which case, the integer is replaced by a pair of a triple (depending of the type) with its value.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Rem" class="def variant constructor anchored"><a href="#type-binary_operator.Rem" class="anchor"></a><code><span>| </span><span><span class="constructor">Rem</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Modulus over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>. Also defined if one of the operands is a <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and the other a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> or <a href="#type-type_expression.Type_color"><code>Type_color</code></a>, in which case, the integer is replaced by a pair of a triple (depending of the type) with its value.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.And" class="def variant constructor anchored"><a href="#type-binary_operator.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean and</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Or" class="def variant constructor anchored"><a href="#type-binary_operator.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean or</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Equal" class="def variant constructor anchored"><a href="#type-binary_operator.Equal" class="anchor"></a><code><span>| </span><span><span class="constructor">Equal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality (polymorphic)</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Diff" class="def variant constructor anchored"><a href="#type-binary_operator.Diff" class="anchor"></a><code><span>| </span><span><span class="constructor">Diff</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inequality (polymorphic)</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Lt" class="def variant constructor anchored"><a href="#type-binary_operator.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&lt; (over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a> and <a href="#type-type_expression.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Gt" class="def variant constructor anchored"><a href="#type-binary_operator.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&gt; (over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a> and <a href="#type-type_expression.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Leq" class="def variant constructor anchored"><a href="#type-binary_operator.Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Leq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&lt;= (over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a> and <a href="#type-type_expression.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></div></li><li id="type-binary_operator.Geq" class="def variant constructor anchored"><a href="#type-binary_operator.Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Geq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&gt;= (over <a href="#type-type_expression.Type_int"><code>Type_int</code></a>, <a href="#type-type_expression.Type_real"><code>Type_real</code></a> and <a href="#type-type_expression.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Binary operators over <a href="#type-expression"><code>expression</code></a>. Operations over <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a>, <a href="#type-type_expression.Type_color"><code>Type_color</code></a> and <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a> are applied member by member (i.e., (a,b) + (c,d) * (a+c,b+d)).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unary_operator"><a href="#type-unary_operator" class="anchor"></a><code><span><span class="keyword">type</span> unary_operator</span><span> = </span></code><ol><li id="type-unary_operator.Opposite" class="def variant constructor anchored"><a href="#type-unary_operator.Opposite" class="anchor"></a><code><span>| </span><span><span class="constructor">Opposite</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary minus (over <a href="#type-type_expression.Type_int"><code>Type_int</code></a> and <a href="#type-type_expression.Type_real"><code>Type_real</code></a>)</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Not" class="def variant constructor anchored"><a href="#type-unary_operator.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean negation</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Head" class="def variant constructor anchored"><a href="#type-unary_operator.Head" class="anchor"></a><code><span>| </span><span><span class="constructor">Head</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Head of a list</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Tail" class="def variant constructor anchored"><a href="#type-unary_operator.Tail" class="anchor"></a><code><span>| </span><span><span class="constructor">Tail</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tail of a list</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Floor" class="def variant constructor anchored"><a href="#type-unary_operator.Floor" class="anchor"></a><code><span>| </span><span><span class="constructor">Floor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The biggest <a href="#type-type_expression.Type_int"><code>Type_int</code></a> smaller than the <a href="#type-type_expression.Type_real"><code>Type_real</code></a> given</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Real_of_int" class="def variant constructor anchored"><a href="#type-unary_operator.Real_of_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Real_of_int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The <a href="#type-type_expression.Type_real"><code>Type_real</code></a> corresponding to the <a href="#type-type_expression.Type_int"><code>Type_int</code></a> given</p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Cos" class="def variant constructor anchored"><a href="#type-unary_operator.Cos" class="anchor"></a><code><span>| </span><span><span class="constructor">Cos</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Cosinus function over <a href="#type-type_expression.Type_real"><code>Type_real</code></a></p><span class="comment-delim">*)</span></div></li><li id="type-unary_operator.Sin" class="def variant constructor anchored"><a href="#type-unary_operator.Sin" class="anchor"></a><code><span>| </span><span><span class="constructor">Sin</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Sinus function over <a href="#type-type_expression.Type_real"><code>Type_real</code></a></p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Unary operator over the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-field_accessor"><a href="#type-field_accessor" class="anchor"></a><code><span><span class="keyword">type</span> field_accessor</span><span> = </span></code><ol><li id="type-field_accessor.Color_field" class="def variant constructor anchored"><a href="#type-field_accessor.Color_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Color_field</span></span></code></li><li id="type-field_accessor.Coord_field" class="def variant constructor anchored"><a href="#type-field_accessor.Coord_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Coord_field</span></span></code></li><li id="type-field_accessor.X_field" class="def variant constructor anchored"><a href="#type-field_accessor.X_field" class="anchor"></a><code><span>| </span><span><span class="constructor">X_field</span></span></code></li><li id="type-field_accessor.Y_field" class="def variant constructor anchored"><a href="#type-field_accessor.Y_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Y_field</span></span></code></li><li id="type-field_accessor.Blue_field" class="def variant constructor anchored"><a href="#type-field_accessor.Blue_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Blue_field</span></span></code></li><li id="type-field_accessor.Red_field" class="def variant constructor anchored"><a href="#type-field_accessor.Red_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Red_field</span></span></code></li><li id="type-field_accessor.Green_field" class="def variant constructor anchored"><a href="#type-field_accessor.Green_field" class="anchor"></a><code><span>| </span><span><span class="constructor">Green_field</span></span></code></li></ol></div><div class="spec-doc"><p>Accessors to field of <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a>, <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> and <a href="#type-type_expression.Type_color"><code>Type_color</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expression"><a href="#type-expression" class="anchor"></a><code><span><span class="keyword">type</span> expression</span><span> = </span></code><ol><li id="type-expression.Const_int" class="def variant constructor anchored"><a href="#type-expression.Const_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Const_int</span> <span class="keyword">of</span> int * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Const_real" class="def variant constructor anchored"><a href="#type-expression.Const_real" class="anchor"></a><code><span>| </span><span><span class="constructor">Const_real</span> <span class="keyword">of</span> float * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Const_bool" class="def variant constructor anchored"><a href="#type-expression.Const_bool" class="anchor"></a><code><span>| </span><span><span class="constructor">Const_bool</span> <span class="keyword">of</span> bool * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Coord" class="def variant constructor anchored"><a href="#type-expression.Coord" class="anchor"></a><code><span>| </span><span><span class="constructor">Coord</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expression.Type_coord"><code>Type_coord</code></a> from the two expressions in argument.</p><span class="comment-delim">*)</span></div></li><li id="type-expression.Color" class="def variant constructor anchored"><a href="#type-expression.Color" class="anchor"></a><code><span>| </span><span><span class="constructor">Color</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expression.Type_color"><code>Type_color</code></a> from the three expressions in argument.</p><span class="comment-delim">*)</span></div></li><li id="type-expression.Pixel" class="def variant constructor anchored"><a href="#type-expression.Pixel" class="anchor"></a><code><span>| </span><span><span class="constructor">Pixel</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a> from the two expressions in argument.</p><span class="comment-delim">*)</span></div></li><li id="type-expression.Variable" class="def variant constructor anchored"><a href="#type-expression.Variable" class="anchor"></a><code><span>| </span><span><span class="constructor">Variable</span> <span class="keyword">of</span> string * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Binary_operator" class="def variant constructor anchored"><a href="#type-expression.Binary_operator" class="anchor"></a><code><span>| </span><span><span class="constructor">Binary_operator</span> <span class="keyword">of</span> <a href="#type-binary_operator">binary_operator</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Unary_operator" class="def variant constructor anchored"><a href="#type-expression.Unary_operator" class="anchor"></a><code><span>| </span><span><span class="constructor">Unary_operator</span> <span class="keyword">of</span> <a href="#type-unary_operator">unary_operator</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Field_accessor" class="def variant constructor anchored"><a href="#type-expression.Field_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Field_accessor</span> <span class="keyword">of</span> <a href="#type-field_accessor">field_accessor</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.List" class="def variant constructor anchored"><a href="#type-expression.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><a href="#type-expression">expression</a> list</span> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-expression.Append" class="def variant constructor anchored"><a href="#type-expression.Append" class="anchor"></a><code><span>| </span><span><span class="constructor">Append</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li></ol></div><div class="spec-doc"><p>The expressions of the language. Only non-obvious cases are commented below. Every expression contains an <a href="Annotation/index.html#type-t"><code>Annotation.t</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-statement"><a href="#type-statement" class="anchor"></a><code><span><span class="keyword">type</span> statement</span><span> = </span></code><ol><li id="type-statement.Affectation" class="def variant constructor anchored"><a href="#type-statement.Affectation" class="anchor"></a><code><span>| </span><span><span class="constructor">Affectation</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-statement.Declaration" class="def variant constructor anchored"><a href="#type-statement.Declaration" class="anchor"></a><code><span>| </span><span><span class="constructor">Declaration</span> <span class="keyword">of</span> string * <a href="#type-type_expression">type_expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-statement.Block" class="def variant constructor anchored"><a href="#type-statement.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <span><a href="#type-statement">statement</a> list</span> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block of consecutive statements. Declarations in this block are local to it</p><span class="comment-delim">*)</span></div></li><li id="type-statement.IfThenElse" class="def variant constructor anchored"><a href="#type-statement.IfThenElse" class="anchor"></a><code><span>| </span><span><span class="constructor">IfThenElse</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li><li id="type-statement.For" class="def variant constructor anchored"><a href="#type-statement.For" class="anchor"></a><code><span>| </span><span><span class="constructor">For</span> <span class="keyword">of</span> string * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For loop. <code>For(str,init,target,step,body,annot)</code> starts by initialising variable <code>str</code> (which must be declared) to the value of <code>init</code>, and executes <code>body</code> and then increments <code>str</code> by the value of <code>step</code> as long as the value in <code>str</code> is smaller than that of <code>target</code>. <code>target</code> is reevaluated at each step. Can be used for <a href="#type-type_expression.Type_int"><code>Type_int</code></a> or <a href="#type-type_expression.Type_real"><code>Type_real</code></a> variables</p><span class="comment-delim">*)</span></div></li><li id="type-statement.Foreach" class="def variant constructor anchored"><a href="#type-statement.Foreach" class="anchor"></a><code><span>| </span><span><span class="constructor">Foreach</span> <span class="keyword">of</span> string * <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Foreach(str,list,body,annotation)</code> requires that <code>list</code> is a <a href="#type-type_expression.Type_list"><code>Type_list</code></a>. It applies <code>body</code> to every element of the list (from left to right). In <code>body</code>, the current element of the loop is stored in variable <code>str</code> (which is not required to be declared)</p><span class="comment-delim">*)</span></div></li><li id="type-statement.Draw_pixel" class="def variant constructor anchored"><a href="#type-statement.Draw_pixel" class="anchor"></a><code><span>| </span><span><span class="constructor">Draw_pixel</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Draw_pixel(pixel,annot)</code> draws <code>pixel</code> on the window of the program. <code>pixel</code> must be of type <a href="#type-type_expression.Type_pixel"><code>Type_pixel</code></a></p><span class="comment-delim">*)</span></div></li><li id="type-statement.Nop" class="def variant constructor anchored"><a href="#type-statement.Nop" class="anchor"></a><code><span>| </span><span><span class="constructor">Nop</span></span></code></li><li id="type-statement.Print" class="def variant constructor anchored"><a href="#type-statement.Print" class="anchor"></a><code><span>| </span><span><span class="constructor">Print</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Print(expr,annot)</code> displays the value of <code>expr</code> in the terminal (for debugging purposes)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The statements of the language. Only non-obvious cases are commented below. Every statement contains an <a href="Annotation/index.html#type-t"><code>Annotation.t</code></a>, except <a href="#type-statement.Nop"><code>Nop</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-argument"><a href="#type-argument" class="anchor"></a><code><span><span class="keyword">type</span> argument</span><span> = </span></code><ol><li id="type-argument.Argument" class="def variant constructor anchored"><a href="#type-argument.Argument" class="anchor"></a><code><span>| </span><span><span class="constructor">Argument</span> <span class="keyword">of</span> string * <a href="#type-type_expression">type_expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></li></ol></div><div class="spec-doc"><p>Argument of the program</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-program"><a href="#type-program" class="anchor"></a><code><span><span class="keyword">type</span> program</span><span> = </span></code><ol><li id="type-program.Program" class="def variant constructor anchored"><a href="#type-program.Program" class="anchor"></a><code><span>| </span><span><span class="constructor">Program</span> <span class="keyword">of</span> <span><a href="#type-argument">argument</a> list</span> * <a href="#type-statement">statement</a></span></code></li></ol></div><div class="spec-doc"><p>Type that represent a Stippled program. It contains a (possibly empty) list of declaration of arguments that will be read on the arguments of the interpreter, and a statement that is the body of the program. Every type can be read of argument, except of list of non-base type (i.e. list of int can be read, but not list of list of int).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_type_expression"><a href="#val-string_of_type_expression" class="anchor"></a><code><span><span class="keyword">val</span> string_of_type_expression : <span><a href="#type-type_expression">type_expression</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_binary_operator"><a href="#val-string_of_binary_operator" class="anchor"></a><code><span><span class="keyword">val</span> string_of_binary_operator : <span><a href="#type-binary_operator">binary_operator</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_unary_operator"><a href="#val-string_of_unary_operator" class="anchor"></a><code><span><span class="keyword">val</span> string_of_unary_operator : <span><a href="#type-unary_operator">unary_operator</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_field_accessor"><a href="#val-string_of_field_accessor" class="anchor"></a><code><span><span class="keyword">val</span> string_of_field_accessor : <span><a href="#type-field_accessor">field_accessor</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_expression"><a href="#val-string_of_expression" class="anchor"></a><code><span><span class="keyword">val</span> string_of_expression : <span><a href="#type-expression">expression</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_pos"><a href="#val-string_of_pos" class="anchor"></a><code><span><span class="keyword">val</span> string_of_pos : <span><span>(<a href="#type-expression">expression</a> * <a href="#type-expression">expression</a>)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_color"><a href="#val-string_of_color" class="anchor"></a><code><span><span class="keyword">val</span> string_of_color : <span><span>(<a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a>)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_list"><a href="#val-string_of_list" class="anchor"></a><code><span><span class="keyword">val</span> string_of_list : <span><span><a href="#type-expression">expression</a> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_statement"><a href="#val-pp_statement" class="anchor"></a><code><span><span class="keyword">val</span> pp_statement : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-statement">statement</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_argument"><a href="#val-pp_argument" class="anchor"></a><code><span><span class="keyword">val</span> pp_argument : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-argument">argument</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_program"><a href="#val-pp_program" class="anchor"></a><code><span><span class="keyword">val</span> pp_program : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-program">program</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>
